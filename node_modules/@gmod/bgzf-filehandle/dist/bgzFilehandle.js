"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const generic_filehandle2_1 = require("generic-filehandle2");
// locals
const unzip_1 = require("./unzip");
const gziIndex_1 = __importDefault(require("./gziIndex"));
const util_1 = require("./util");
class BgzFilehandle {
    constructor({ filehandle, path, gziFilehandle, gziPath, }) {
        if (filehandle) {
            this.filehandle = filehandle;
        }
        else if (path) {
            this.filehandle = new generic_filehandle2_1.LocalFile(path);
        }
        else {
            throw new TypeError('either filehandle or path must be defined');
        }
        if (!gziFilehandle && !gziPath && !path) {
            throw new TypeError('either gziFilehandle or gziPath must be defined');
        }
        this.gzi = new gziIndex_1.default({
            filehandle: gziFilehandle,
            path: !gziFilehandle && !gziPath && path ? gziPath : `${path}.gzi`,
        });
    }
    async stat() {
        const compressedStat = await this.filehandle.stat();
        return Object.assign(compressedStat, {
            size: await this.getUncompressedFileSize(),
            blocks: undefined,
            blksize: undefined,
        });
    }
    async getUncompressedFileSize() {
        // read the last block's ISIZE (see gzip RFC),
        // and add it to its uncompressedPosition
        const [, uncompressedPosition] = await this.gzi.getLastBlock();
        const { size } = await this.filehandle.stat();
        // note: there should be a 28-byte EOF marker (an empty block) at
        // the end of the file, so we skip backward past that
        const buf = await this.filehandle.read(4, size - 28 - 4);
        const dataView = new DataView(buf.buffer);
        const lastBlockUncompressedSize = dataView.getUint32(0, true);
        return uncompressedPosition + lastBlockUncompressedSize;
    }
    async _readAndUncompressBlock([compressedPosition], [nextCompressedPosition]) {
        let next = nextCompressedPosition;
        if (!next) {
            next = (await this.filehandle.stat()).size;
        }
        // read the compressed data into the block buffer
        const blockCompressedLength = next - compressedPosition;
        const blockBuffer = await this.filehandle.read(blockCompressedLength, compressedPosition);
        // uncompress it
        return (0, unzip_1.unzip)(blockBuffer);
    }
    async read(length, position) {
        const blockPositions = await this.gzi.getRelevantBlocksForRead(length, position);
        const blocks = [];
        for (let blockNum = 0; blockNum < blockPositions.length - 1; blockNum += 1) {
            const uncompressedBuffer = await this._readAndUncompressBlock(blockPositions[blockNum], blockPositions[blockNum + 1]);
            const [, uncompressedPosition] = blockPositions[blockNum];
            const sourceOffset = uncompressedPosition >= position ? 0 : position - uncompressedPosition;
            const sourceEnd = Math.min(position + length, uncompressedPosition + uncompressedBuffer.length) - uncompressedPosition;
            if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {
                blocks.push(uncompressedBuffer.subarray(sourceOffset, sourceEnd));
            }
        }
        return (0, util_1.concatUint8Array)(blocks);
    }
}
exports.default = BgzFilehandle;
//# sourceMappingURL=bgzFilehandle.js.map