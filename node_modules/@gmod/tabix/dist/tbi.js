"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const virtualOffset_1 = __importStar(require("./virtualOffset"));
const chunk_1 = __importDefault(require("./chunk"));
const bgzf_filehandle_1 = require("@gmod/bgzf-filehandle");
const util_1 = require("./util");
const indexFile_1 = __importDefault(require("./indexFile"));
const long_1 = require("./long");
const TBI_MAGIC = 21578324; // TBI\1
const TAD_LIDX_SHIFT = 14;
/**
 * calculate the list of bins that may overlap with region [beg,end)
 * (zero-based half-open)
 */
function reg2bins(beg, end) {
    beg += 1; // < convert to 1-based closed
    end -= 1;
    return [
        [0, 0],
        [1 + (beg >> 26), 1 + (end >> 26)],
        [9 + (beg >> 23), 9 + (end >> 23)],
        [73 + (beg >> 20), 73 + (end >> 20)],
        [585 + (beg >> 17), 585 + (end >> 17)],
        [4681 + (beg >> 14), 4681 + (end >> 14)],
    ];
}
class TabixIndex extends indexFile_1.default {
    async lineCount(refName, opts = {}) {
        const indexData = await this.parse(opts);
        const refId = indexData.refNameToId[refName];
        if (refId === undefined) {
            return -1;
        }
        const idx = indexData.indices[refId];
        if (!idx) {
            return -1;
        }
        return indexData.indices[refId].stats?.lineCount ?? -1;
    }
    // fetch and parse the index
    async _parse(opts = {}) {
        const buf = await this.filehandle.readFile(opts);
        const bytes = await (0, bgzf_filehandle_1.unzip)(buf);
        (0, util_1.checkAbortSignal)(opts.signal);
        const dataView = new DataView(bytes.buffer);
        const magic = dataView.getUint32(0, true);
        if (magic !== TBI_MAGIC /* "TBI\1" */) {
            throw new Error('Not a TBI file');
        }
        // number of reference sequences in the index
        const refCount = dataView.getUint32(4, true);
        const formatFlags = dataView.getUint32(8, true);
        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';
        const formatOpts = {
            0: 'generic',
            1: 'SAM',
            2: 'VCF',
        };
        const format = formatOpts[formatFlags & 0xf];
        if (!format) {
            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);
        }
        const columnNumbers = {
            ref: dataView.getInt32(12, true),
            start: dataView.getInt32(16, true),
            end: dataView.getInt32(20, true),
        };
        const metaValue = dataView.getInt32(24, true);
        const depth = 5;
        const maxBinNumber = ((1 << ((depth + 1) * 3)) - 1) / 7;
        const maxRefLength = 2 ** (14 + depth * 3);
        const metaChar = metaValue ? String.fromCharCode(metaValue) : null;
        const skipLines = dataView.getInt32(28, true);
        // read sequence dictionary
        const nameSectionLength = dataView.getInt32(32, true);
        const { refNameToId, refIdToName } = this._parseNameBytes(bytes.slice(36, 36 + nameSectionLength));
        // read the indexes for each reference sequence
        let currOffset = 36 + nameSectionLength;
        let firstDataLine;
        const indices = new Array(refCount).fill(0).map(() => {
            // the binning index
            const binCount = dataView.getInt32(currOffset, true);
            currOffset += 4;
            const binIndex = {};
            let stats;
            for (let j = 0; j < binCount; j += 1) {
                const bin = dataView.getUint32(currOffset, true);
                currOffset += 4;
                if (bin > maxBinNumber + 1) {
                    throw new Error('tabix index contains too many bins, please use a CSI index');
                }
                else if (bin === maxBinNumber + 1) {
                    const chunkCount = dataView.getInt32(currOffset, true);
                    currOffset += 4;
                    if (chunkCount === 2) {
                        stats = this.parsePseudoBin(bytes, currOffset);
                    }
                    currOffset += 16 * chunkCount;
                }
                else {
                    const chunkCount = dataView.getInt32(currOffset, true);
                    currOffset += 4;
                    const chunks = new Array(chunkCount);
                    for (let k = 0; k < chunkCount; k += 1) {
                        const u = (0, virtualOffset_1.fromBytes)(bytes, currOffset);
                        const v = (0, virtualOffset_1.fromBytes)(bytes, currOffset + 8);
                        currOffset += 16;
                        firstDataLine = this._findFirstData(firstDataLine, u);
                        chunks[k] = new chunk_1.default(u, v, bin);
                    }
                    binIndex[bin] = chunks;
                }
            }
            // the linear index
            const linearCount = dataView.getInt32(currOffset, true);
            currOffset += 4;
            const linearIndex = new Array(linearCount);
            for (let k = 0; k < linearCount; k += 1) {
                linearIndex[k] = (0, virtualOffset_1.fromBytes)(bytes, currOffset);
                currOffset += 8;
                firstDataLine = this._findFirstData(firstDataLine, linearIndex[k]);
            }
            return {
                binIndex,
                linearIndex,
                stats,
            };
        });
        return {
            indices,
            metaChar,
            maxBinNumber,
            maxRefLength,
            skipLines,
            firstDataLine,
            columnNumbers,
            coordinateType,
            format,
            refIdToName,
            refNameToId,
            maxBlockSize: 1 << 16,
        };
    }
    parsePseudoBin(bytes, offset) {
        return {
            lineCount: (0, long_1.longFromBytesToUnsigned)(bytes, offset + 16),
        };
    }
    _parseNameBytes(namesBytes) {
        let currRefId = 0;
        let currNameStart = 0;
        const refIdToName = [];
        const refNameToId = {};
        const decoder = new TextDecoder('utf8');
        for (let i = 0; i < namesBytes.length; i += 1) {
            if (!namesBytes[i]) {
                if (currNameStart < i) {
                    const refName = this.renameRefSeq(decoder.decode(namesBytes.subarray(currNameStart, i)));
                    refIdToName[currRefId] = refName;
                    refNameToId[refName] = currRefId;
                }
                currNameStart = i + 1;
                currRefId += 1;
            }
        }
        return {
            refNameToId,
            refIdToName,
        };
    }
    async blocksForRange(refName, min, max, opts = {}) {
        if (min < 0) {
            min = 0;
        }
        const indexData = await this.parse(opts);
        const refId = indexData.refNameToId[refName];
        if (refId === undefined) {
            return [];
        }
        const ba = indexData.indices[refId];
        if (!ba) {
            return [];
        }
        const minOffset = ba.linearIndex.length
            ? ba.linearIndex[min >> TAD_LIDX_SHIFT >= ba.linearIndex.length
                ? ba.linearIndex.length - 1
                : min >> TAD_LIDX_SHIFT]
            : new virtualOffset_1.default(0, 0);
        if (!minOffset) {
            console.warn('querying outside of possible tabix range');
        }
        // const { linearIndex, binIndex } = indexes
        const overlappingBins = reg2bins(min, max); // List of bin #s that overlap min, max
        const chunks = [];
        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned
        for (const [start, end] of overlappingBins) {
            for (let bin = start; bin <= end; bin++) {
                if (ba.binIndex[bin]) {
                    for (const c of ba.binIndex[bin]) {
                        chunks.push(new chunk_1.default(c.minv, c.maxv, bin));
                    }
                }
            }
        }
        // Use the linear index to find minimum file position of chunks that could
        // contain alignments in the region
        const nintv = ba.linearIndex.length;
        let lowest = null;
        const minLin = Math.min(min >> 14, nintv - 1);
        const maxLin = Math.min(max >> 14, nintv - 1);
        for (let i = minLin; i <= maxLin; ++i) {
            const vp = ba.linearIndex[i];
            if (vp) {
                if (!lowest || vp.compareTo(lowest) < 0) {
                    lowest = vp;
                }
            }
        }
        return (0, util_1.optimizeChunks)(chunks, lowest);
    }
}
exports.default = TabixIndex;
//# sourceMappingURL=tbi.js.map